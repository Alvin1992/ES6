<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>module</title>
</head>
<body>
    <script>
        // 在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种
        // 前者用于服务器，后者用于浏览器，都是运行时加载
        // ES6 模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量
        // ES6 模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入 编译时加载或者静态加载
        // ES6 模块是编译时加载，使得静态分析成为可能
        // 除了静态加载带来的各种好处，ES6 模块还有以下好处
        // 1. 不再需要UMD模块格式了，将来服务器和浏览器都会支持 ES6 模块格式
        // 2. 将来浏览器的新 API 就能用模块格式提供，不再必须做成全局变量或者navigator对象的属性
        // 3. 不再需要对象作为命名空间


        // ES6 的模块自动采用严格模式，不管你有没有在模块头部加上"use strict";
        // ES6 模块之中，顶层的this指向undefined，即不应该在顶层代码使用this


        // export命令用于规定模块的对外接口
        // 一个模块就是一个独立的文件，该文件内部的所有变量，外部无法获取
        // 如果希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量
        /*export var firstName = 'Michael';
        export var lastName = 'Jackson';
        export var year = 1958;
        // 等价于
        var firstName = 'Michael';
        var lastName = 'Jackson';
        var year = 1958;
        export {firstName, lastName, year};
        // 应该优先考虑使用这种写法，可以在脚本尾部，一眼看清楚输出了哪些变量*/
        // export命令除了输出变量，还可以输出函数或类（class）
        // 通常情况下，export输出的变量就是本来的名字，但是可以使用as关键字重命名
        /*function v1() { ... }
        function v2() { ... }

        export {
            v1 as streamV1,
            v2 as streamV2,
            v2 as streamLatestVersion
        };*/
        // 重命名后，可以用不同的名字输出两次
        // export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系
        /*// 报错
        export 1;

        // 报错
        var m = 1;
        export m;*/
        // 正确写法
        /*// 写法一
        export var m = 1;

        // 写法二
        var m = 1;
        export {m};

        // 写法三
        var n = 1;
        export {n as m};*/
        // export语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值
        // export命令可以出现在模块的任何位置，只要处于模块顶层就可以


        // import命令用于输入其他模块提供的功能
        // import命令接受一对大括号，里面指定要从其他模块导入的变量名
        // 大括号里面的变量名，必须与被导入模块对外接口的名称相同
        // 如果想为输入的变量重新取一个名字，import命令要使用as关键字，将输入的变量重命名
        // import { lastName as surname } from './profile';
        // import后面的from指定模块文件的位置，可以是相对路径，也可以是绝对路径，.js路径可以省略
        // 如果只是模块名，不带有路径，那么必须有配置文件，告诉 JavaScript 引擎该模块的位置
        // import命令具有提升效果，会提升到整个模块的头部，首先执行
        /*foo();

        import { foo } from 'my_module';*/
        // 这种行为的本质是，import命令是编译阶段执行的，在代码运行之前
        // 由于import是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构
        /*// 报错
        import { 'f' + 'oo' } from 'my_module';

        // 报错
        let module = 'my_module';
        import { foo } from module;

        // 报错
        if (x === 1) {
        import { foo } from 'module1';
        } else {
        import { foo } from 'module2';
        }*/

        // import语句会执行所加载的模块
        // import 'lodash';
        // 仅仅执行lodash模块，但是不输入任何值

        // 如果多次重复执行同一句import语句，那么只会执行一次，而不会执行多次
        /*import { foo } from 'my_module';
        import { bar } from 'my_module';

        // 等同于
        import { foo, bar } from 'my_module';*/
    </script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>string</title>
</head>
<body>
<script>
    // 字符的Unicode表示法
    // JavaScript允许采用\uxxxx形式表示一个字符，其中“xxxx”表示字符的码点。
    /*console.log('\u0061');*/

    // 但是，这种表示法只限于\u0000——\uFFFF之间的字符。
    // 超出这个范围的字符，必须用两个双字节的形式表达。
    /*console.log("\uD842\uDFB7");*/

    // 如果直接在“\u”后面跟上超过0xFFFF的数值（比如\u20BB7），JavaScript会理解成“\u20BB+7”。
    // 所以会打印出\u20BB的字符和7
    /*console.log("\u20BB7");*/

    // ES6对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。
    /*console.log('\u{20BB7}');
    console.log('\u{41}\u{42}\u{43}');
    let hello = 123;
    console.log(hell\u{6F});  // 123*/

    // 这个例子表明，大括号表示法与四字节的UTF-16编码是等价的。
    /*console.log('\u{1F680}' === '\uD83D\uDE80');*/

    // 有了这种表示法之后，JavaScript共有6种方法可以表示一个字符。
    /*console.log('\z' === 'z');
    console.log('\172' === 'z');   // ASCII
    console.log('\x7A' === 'z');   // 八进制
    console.log('\u007A' === 'z'); // 十六进制
    console.log('\u{7A}' === 'z');*/

    // codePointAt
    // JavaScript内部，字符以UTF-16的格式储存，每个字符固定为2个字节。
    // 对于那些需要4个字节储存的字符（Unicode码点大于0xFFFF的字符），JavaScript会认为它们是两个字符。
    /*var s = '𠮷'
    console.log(s.length); // 2
    console.log(s.charAt(0));
    console.log(s.charAt(1));
    console.log(s.charCodeAt(0)); // 55362
    console.log(s.charCodeAt(1)); // 57271*/
    // 汉字“𠮷”的码点是0x20BB7，UTF-16编码为0xD842 0xDFB7（十进制为55362 57271），需要4个字节储存。
    // 对于这种4个字节的字符，JavaScript不能正确处理，字符串长度会误判为2，
    // 而且charAt方法无法读取整个字符，charCodeAt方法只能分别返回前两个字节和后两个字节的值。

    // ES6提供了codePointAt方法，能够正确处理4个字节储存的字符，返回一个字符的码点。
    // codePointAt方法会正确返回32位的UTF-16字符的码点。对于那些两个字节储存的常规字符，它的返回结果与charCodeAt方法相同。
    let str = '𠮷a';
    console.log(str.codePointAt(0));
    console.log(str.codePointAt(1)); // 57271
    console.log(str.charCodeAt(1)); // 57271
    console.log(str.charCodeAt(2)); // 97
    console.log(str.codePointAt(2)); // 97
    // codePointAt方法的参数，是字符在字符串中的位置（从0开始）。
    // 上面代码中，JavaScript将“𠮷a”视为三个字符，codePointAt方法在第一个字符上，正确地识别了“𠮷”，
    // 返回了它的十进制码点134071（即十六进制的20BB7）。
    // 在第二个字符（即“𠮷”的后两个字节）和第三个字符“a”上，codePointAt方法的结果与charCodeAt方法相同。

    // codePointAt方法返回的是码点的十进制值，如果想要十六进制的值，可以使用toString方法转换一下。
    console.log(str.codePointAt(0).toString(16)); // 20bb7
    console.log(str.charCodeAt(2).toString(16)); // 61

    // codePointAt方法的参数，仍然是不正确的。
    // 比如，上面代码中，字符a在字符串s的正确位置序号应该是1，但是必须向charCodeAt方法传入2。
    // 解决这个问题的一个办法是使用for...of循环，因为它会正确识别32位的UTF-16字符。
    for (let ch of str) {
        console.log(ch.codePointAt(0).toString(16));
    }

    // codePointAt方法是测试一个字符由两个字节还是由四个字节组成的最简单方法。
    function is32Bit(s) {
        return s.codePointAt(0) > 0xFFFF;
    }
    console.log(is32Bit('𠮷'));
    console.log(is32Bit('a'));
</script>
</body>
</html>
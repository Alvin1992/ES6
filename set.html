<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>set</title>
</head>
<body>
    <script>
        // ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值
        // Set 本身是一个构造函数，用来生成 Set 数据结构
        let s = new Set();
        [1,2,3,4,2,5,4].forEach((x) => s.add(x));
        console.log(s);


        // Set 函数可以接受一个数组（或类似数组的对象）作为参数，用来初始化
        let s1 = new Set([1,2,3,4,5,5,5,5,5,5]);
        console.log(s1);
        // 利用 set 进行数组去重
        let arr = [1,2,6,3,5,3,56,7,5,3,1,2, 'foo', 'bar', 'foo'];
        console.log([...new Set(arr)]);
        // 向Set加入值的时候，不会发生类型转换
        // Set内部判断两个值是否不同，使用的算法叫做“Same-value equality”


        // 实例的属性
        console.log(s1.constructor);  // 构造函数
        console.log(s1.size); // 实例的成员总数


        // 方法
        // 操作方法
        // add(value)：添加某个值，返回Set结构本身
        // delete(value)：删除某个值，返回一个布尔值，表示删除是否成功
        // has(value)：返回一个布尔值，表示该值是否为Set的成员
        // clear()：清除所有成员，没有返回值
        let s2 = new Set([1,2,4,6,3,656,3,5,60,3]);
        console.log(s2.delete(1));
        console.log(s2.has(1));
        console.log(s2.add(1));
        s2.clear();
        console.log(s2);
        // Array.from方法可以将Set结构转为数组
        // 数组去重的另外一种方法
        function dedupe(array) {
            return Array.from(new Set(array));
        }
        console.log(dedupe([1,1,2,2,5,6,78,3,4,2,31]));
        // 遍历操作
        // keys()：返回键名的遍历器
        // values()：返回键值的遍历器
        // entries()：返回键值对的遍历器
        // forEach()：使用回调函数遍历每个成员， forEach方法的参数就是一个处理函数
        // 该函数的参数依次为键值、键名、集合本身
        // 另外，forEach方法还可以有第二个参数，表示绑定的this对象
        // Set的遍历顺序就是插入顺序
        // 这个特性有时非常有用，比如使用Set保存一个回调函数列表，调用时就能保证按照添加顺序调用
        // keys方法和values方法的行为完全一致
        let a = new Set([1, 2, 3]);
        let b = new Set([4, 3, 2]);
        // 并集
        let union = new Set([...a, ...b]);
        // Set {1, 2, 3, 4}
        // 交集
        let intersect = new Set([...a].filter(x => b.has(x)));
        // set {2, 3}
        // 差集
        let difference = new Set([...a].filter(x => !b.has(x)));

        // WeakSet结构与Set类似，也是不重复的值的集合
        // WeakSet的成员只能是对象，而不能是其他类型的值
        // WeakSet中的对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用
        // 如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存
        // 不考虑该对象还存在于WeakSet之中
        // 无法引用WeakSet的成员，WeakSet是不可遍历的
        // 作为构造函数，WeakSet可以接受一个数组或类似数组的对象作为参数
        // 任何具有iterable接口的对象，都可以作为WeakSet的参数
        let arr1 = [[1,2], [3,4]];
        let ws = new WeakSet(arr1);
        console.log(ws);  // 是 arr1 的成员成为 weakset 的成员不是 arr1 这个数组

        // WeakSet.prototype.add(value)：向WeakSet实例添加一个新成员
        // WeakSet.prototype.delete(value)：清除WeakSet实例的指定成员
        // WeakSet.prototype.has(value)：返回一个布尔值，表示某个值是否在WeakSet实例之中


        // WeakSet的一个用处，是储存DOM节点，而不用担心这些节点从文档移除时，会引发内存泄漏
    </script>
</body>
</html>